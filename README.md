# goit-algo-hw-08

**Мова:** Python 3.10+

Реалізація трьох завдань без зовнішніх залежностей.

## Структура проекту
```
goit-algo-hw-08/
├── trees.py        # BST та AVL + функції: find_min, sum_tree
├── cables.py       # Задача "мережеві кабелі" через купу (heapq)
├── main.py         # Демонстраційний запуск
├── tests.py        # Юніт-тести (unittest)
└── README.md
```

##Запуск тестів

```bash
python3 main.py
```

##Опис алгоритмів

###Завдання 1 — пошук мінімального значення у BST/AVL дереві
Алгоритм послідовно проходить по лівих нащадках кореня дерева, оскільки в BST/AVL найменше значення завжди знаходиться в крайньому лівому вузлі.
Складність: `O(h)`, де `h` — висота дерева (для збалансованого AVL дерева ~ `O(log n))`.
Функція: `find_min(root)` у файлі `trees.py`. Для порожнього дерева повертає `None`.

###Завдання 2 — обчислення суми значень у дереві
Використовується ітеративний обхід дерева з використанням стеку. Кожне значення вузла додається до загальної суми.
Складність: `O(n)` за часом та `O(h)` за пам'яттю, де `n `— кількість вузлів, `h` — висота дерева.
Функція: `sum_tree(root)` у файлі `trees.py`.


###Завдання 3 — оптимізація з'єднання мережевих кабелів
Застосовано жадібний підхід: на кожному кроці об'єднуються два найкоротші кабелі, що мінімізує загальні витрати. Алгоритм аналогічний побудові коду Хаффмана.
Для ефективного вибору мінімальних елементів використано структуру даних "піраміда" (мін-купа) з модуля `heapq`.
Функція: `connect_cables(lengths)` у файлі `cables.py` повертає загальну вартість з'єднання та список виконаних об'єднань.
Складність: `O(n log n)`.

###Перевірка коректності
- Юніт-тести покривають основні функціональності та граничні випадки.
- Демонстраційний скрипт `main.py` показує приклади роботи всіх реалізованих алгоритмів.
